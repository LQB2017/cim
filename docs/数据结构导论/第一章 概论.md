## 基本概念

### 计算机处理问题的一般步骤

1. 具体问题抽象为数学模型。  
2. 设计求解该数学模型的算法。
3. 编程、调试、运行
![](../_media/Drawing%202023-01-29%2020.15.59.excalidraw.svg)

### 数据

数据（data）是信息的载体，是描述客观事物的数字、字符以及所有能够输入到计算机中并被计算机程序处理的符号的集合。计算机能够处理多种形式的数据。主要分为两大类：一类是**数值型**的数据，主要用于工程和科学计算等领域；另一类是**非数值**数据，如字符型数据，以及图形、图像、声音等多媒体数据。

### 数据元素

数据元素（data element）是表示数据的基本单位，是数据这个集合中的一个个体。在数据结构中数据元素经常称之为结点（node）。

### 数据项

一个数据元素又可以由若干个数据项（data item）组成。数据项有两种：一种是初等项，是具有独立含义的最小标识单位；另一种是组合项，是具有独立含义的标识单位，它通常由一个或多个初等项和组合项组成。

### 数据对象

数据对象（data object）是具有相同性质的数据元素的集合，是数据这个集合的一个子集。

## 数据的逻辑结构

数据的逻辑结构可以分为两大类：一类是线性结构，另一类是非线性结构。

![[../_media/数据的逻辑结构.png]]

### 线性结构

**线性结构**有且仅有一个开始结点和一个终端结点，并且每个结点至多只有一个前驱和一个后继。线性表是一种典型的线性结构。前面介绍的职工工资表就是一个线性表。

### 非线性结构

非线性结构中的一个结点可能有多个前驱和后继。如果一个结点至多只有一个前驱而可以有多个后继，这种结构就是**树形结构**。树形结构是一种非常重要的非线性结构。如果对结点的前驱和后继的个数都不作限制，即任何两个结点之间都可能有邻接关系，我们把这种结构就叫作**图**。图是更一般、更为复杂的一种数据结构。



## 数据的存储结构

数据的存储结构是数据的逻辑结构用计算机语言的实现（或称为存储映象），它是依赖于计算机语言的。

![[../_media/存储结构.png]]

### 顺序存储

顺序存储方式是把逻辑上相邻的结点存储在物理位置也相邻的存储单元里，结点之间的逻辑关系用存储单元的邻接关系来体现，即在所存储的区域中原来逻辑上相邻的结点其物理位置也相邻。由此得到的存储表示称为顺序存储结构（sequential storage structure）。顺序存储主要用于线性结构，非线性结构也可以通过某种线性化的方法来实现顺序存储。通常顺序存储是用高级语言的一维数组来描述的。

### 链式存储

链接存储方式对逻辑上相邻的结点不要求在存储的物理位置上亦相邻，结点间的逻辑关系是由附加的指针字段来表示的。由此得到的存储表示称为链接存储结构（linked storage structure），通常要借助于程序设计语言的指针类型来描述它。非线性结构常用链接存储方式，线性结构也可以使用链接存储方式。

### 索引存储方式

索引存储方式是在存储结点数据的同时，还需建立附加的索引表。索引表中的每一项称为索引项，一般由关键字和地址组成。关键字（key）是能够唯一标识一个结点的一个或多个字段。若每个结点在索引表中都有一个索引项，则该索引表称作为稠密索引（dense index）。若一组结点在索引表中只对应一个索引项，则把这样的索引表称作为稀疏索引（sparse index）。稠密索引中索引项的地址指示该结点的存储位置，而稀疏索引中索引项的地址则是指示一组结点的起始存储位置。

### 散列存储方式

散列存储方法就是根据结点的关键字通过反映结点与存储地址之间对应关系的函数直接计算出该结点的存储地址（或位置）。


## 运算

数据的运算是定义在数据的逻辑结构上的，每种逻辑结构都有一个运算的集合。

## 数据类型和抽象数据类型

### 数据类型

数据类型（data type）是一组性质相同的值的集合以及在这些值上定义一组操作（运算）的总称。每一种计算机高级语言都有自己的数据类型定义。

### 抽象数据类型

抽象是对事物的简化描述，就是抽取反映问题本质的东西，而忽略非本质的一些细节。抽象可以分为不同的层次，低层次抽象可以作为高层次抽象的一种实现。抽象是人们理解复杂现象和求解复杂问题时经常使用的一种方法。

抽象数据类型可以看作是描述问题的模型，它独立于具体实现。它的优点是将数据和操作封装在一起，使得用户程序只能通过在 ADT 里定义的某些操作来访问其中的数据，从而实现了信息屏蔽与隐藏。

## 算法

### 算法的概念

算法（algorithm）是规则的有穷集合，这些规则规定了解决某一特定类型问题的一个运算（操作）序列。此外一个算法应当具有以下特性。

1. 输入：一个算法必须有若干个输入（包括0个）。
2. 输出：一个算法应该有一个或多个输出。
3. 有穷性：一个算法必须总是在执行有穷步之后结束。
4. 确定性：算法的每一步都应确切地、无歧义地定义。即对于每一种情况，需要执行的动作都应当严格的、清晰的规定。
5. 可行性：算法中每一个运算都应是基本的、可行的，也就是说，它们原则上都是能够由人们仅用笔和纸做有穷次运算即可完成的。

### 算法的描述

常用的描述算法的方式有自然语言、数学语言、流程图、伪语言和程序设计语言等。无论采用哪一种方式，都必须能够精确地描述计算过程。

## 算法分析

### 算法性能的评价标准

数据结构的性能实际上是由实现它其中运算的算法来体现的。对于要解决的同一个问题，往往能编写出许多不同的算法。进行算法评价的目的，既在于从解决同一问题的不同算法中选择出较为合适的一种，又在于知道对现有的算法如何进行进一步的改进，从而设计出更好的算法。

#### 正确性

正确性（correctness）是设计和评价一个算法的首要条件，一个正确的算法是指在合理的数据输入下，能够在有限的运行时间内得出正确的结果。即要求算法能够正确地执行预定的功能和性能要求。这就要求算法的编写者对问题的要求有正确的、深入的理解，并能对问题进行正确的、无歧义的描述和利用算法描述语言（如程序设计语言）正确地实现算法。

#### 可读性

可读性（readability）是指一个算法供人们阅读的方便程度。这是理解、测试和修改算法的需要。一个可读性好的算法，应该是逻辑清晰、符合结构化和模块化的程序设计思想，所有的变量名和函数名的命名必须有实际含义，使人见名知意。在算法中应当适当添加注释，简要说明算法的功能、输入和输出参数的使用规则、重要数据的作用和算法中各程序段完成的主要功能等。必要时，还应当建立相应的文档。

#### 健壮性

健壮性（robustness）是指在异常情况下，算法能够正常运行的能力。正确性与健壮性的区别在于：前者描述算法是在需求范围之内的行为，而后者描述算法是在需求范围之外的行为。健壮性包括：一是容错能力；二是恢复能力。容错能力是指发生异常情况时，系统不出错误的能力；而恢复能力则是指软件发生错误后重新运行时，能否恢复到没有发生错误前的状态的能力。健壮性要求在算法中对输入参数、打开文件、读文件记录，以及子程序调用状态进行自动检错和报错并通过与用户对话的方式来纠错的功能。这也叫做容错性或例外（异常）处理。一个完整的算法应该具备健壮性，能够对不合理的数据进行检查。但在编制算法的开始阶段，可以暂时不管它，集中精力考虑如何实现主要的功能，待到算法成熟时再追加它。

#### 可用性

可用性（usability）是指用户使用软件的容易程度，亦称用户友好性。为便于用户使用，要求算法具有良好的界面，完备的用户文档。因此，算法的设计必须符合抽象数据类型和模块化的要求，最好所有的输入和输出都通过参数表显式地传递，尽量少用公共变量或全局变量，每个算法只完成一个功能。

#### 效率

效率（efficiency）主要是指算法执行时计算机资源的消耗，包括运行时间和存储空间的开销，前者称为算法的时间代价，后者称为算法的空间代价。算法的效率与多种因素有关。例如，所用的计算机系统、可用的存储容量和算法的复杂性等。
算法的性能标准还有很多，如通用性、可移植性等，这些问题的详细讨论已超出了本课程的内容。在数据结构的课程中，我们在兼顾其他性能的基础上，主要考虑算法的效率，即主要讨论算法的时间代价和空间代价。

### 算法的复杂度

#### 时间复杂度

我们把计算机的一次执行，如一次赋值、一次判断、一次输入、一次输出等均看作是一个时间单位，而忽略它们之间在执行时间上的差异，即每条语句执行一次的时间均是单位时间。一个算法的耗费时间，应该是该算法中各个语句执行时间之和，而每个语句的执行时间就是该语句的执行次数。  

O (1)、O ( log2 n )、O (n)、O ( n log2 n)、O (n2 )、O (n3 )、…、O (2n）

![[../_media/函数增长率.png]]

### 空间复杂度

类似于算法的时间复杂度，可以用空间复杂度（space complexity）作为算法所需存储空间的量度，记作
S(n) = O(g(n))
其中，n为问题的规模，g(n)为算法所处理的数据所需的存储空间与算法所需的辅助空间之和。
上式同样地表示出：随着问题规模n的增大，算法执行时所需存储空间的增长率与g(n)的增长率相同，称为算法的渐进空间复杂度（asymptotic space complexity），简称空间复杂度（性）。
在进行算法分析时，一般是重点讨论算法的时间代价，需要时也会讨论算法的空间代价。主要考虑的也只是算法运行时辅助空间的使用量，即除了算法所处理的数据之外所需的附加存储空间的大小，用以比较完成同一功能的几个算法之间的差异和它们的优劣。

## 递归

递归是一种重要的程序设计方法，简单地说，**如果在一个函数或数据结构的定义中有应用了它自身，那么这个函数或数据结构称为是递归定义的**。常应用在函数的递归调用，表现为函数自调。  

任何递归必须同时满足如下两个条件：  
1. 被定义项在定义中的应用（即作为定义项的出现）具有更小的“规模”；  
2. 被定义项在最小“规模”上的定义是非递归的，这是递归的结束条件。