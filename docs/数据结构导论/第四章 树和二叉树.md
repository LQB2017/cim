# 树形结构的概念

## 树的基本概念

### 树的概念

树（tree）是n（n≥0）个结点的有限集T，如果n=0，则称T为空树；
否则T满足如下条件：
1. 有且仅有一个特定的称为根（ root）的结点，它仅有后继，没有前驱；
2. 除根以外的其他结点被划分为m（ m≥0）个互不相交的有限集合T1,T2 ,…,Tm ，其中每一个集合又都是树，并且称为根的子树（subtree ）。

### 树的表示方法

![[../_media/树的表示方法.png]]

### 树的相关术语

- 双亲与子女（parent and child）：结点的子树的根称为该结点的子女，反之，该结点称为子女结点的双亲（父母）。
- 兄弟（sibling）：同一双亲的子女之间互为兄弟。
- 祖先与子孙（ancestor and descendant）：若有一条由k到达kp的路径，则称k是kp的祖先，kp是 k 的子孙。（或者说，结点的祖先是从根到此结点分支上的所有结点；从该结点到终端结点的路径上的所有结点称为该结点的子孙。）
- 边（edge）：树形结构中，两个结点的有序对，称作连接这两个结点的一条边。
- 结点的度数（degree）：是结点所拥有的子树的棵数。
- 树叶（leaf）：度数为0的结点，又称为终端结点。（或者说，没有子树的结点。）
- 分支（branch）结点：非终端结点。（或者说，度数不为0的结点。）
- 结点的层数（level）：根结点的层数为0，其他所有结点的层数等于它父母结点的层数加1。
- 树的高度（height）：树中结点的最大层数。
- 树的度（degree of tree）：树中结点的度数的最大值。
- 有序树与无序树（ordered tree and unordered tree）：在树T中如果各棵子树T1 ，T2 ，…，Tm的相对次序是重要的（即不能互换），则称树T为有向有序树，简称有序树；否则称为无序树。在有序树中，T1 叫做根的第一棵子树，T2 叫做根的第二棵子树等。
 
自然界的树和森林是不同的概念，而在数据结构中的树和树林只有非常微小的差别。删去树的根，树就变成森林（树林），而加上一个根结点，森林就变成树。

## 二叉树

### 二叉树的基本概念

每个结点最多只有两个子女（即不存在度数大于2的结点），并且二叉树的子树有左右之分，其子树的次序不能随意颠倒。

二叉树（binary tree）是n（n≥0）个结点的有限集合，这个集合或者是空集，或者是由一个根结点加上两棵互不相交的、分别称作这个根的左子树和右子树的二叉树组成。

### 二叉树的5种基本形态

![[../_media/二叉树五种基本形态.png]]

### 二叉树的性质

- 性质1：二叉树的第i层上至多有2^i 个结点（i≥0）。
- 性质2：高度为h的二叉树至多有(2^(h+1))-1。  
- 性质3：对任何一棵二叉树，若度数为0的结点（叶结点）个数为n0，度数为2的结点个数为n2，则n0=n2+1。
- 满二叉树：深度为k（k≥1）且有2k-1个结点的二叉树称为满二叉树。  
- 完全二叉树：如果对满二叉树按从上到下，从左到右的顺序编号，并在最下一层删去部分结点（删后最后一层仍有结点），如果删除的这些结点的编号是连续的且删除的结点中含有最大编号的结点，那么这棵二叉树就是完全二叉树。
- 对于完全二叉树，还有以下两个重要性质：  
　　性质4：含有n个结点的完全二叉树的深度为 。  
　　性质5：如果将一棵有n个结点的完全二叉树按层编号，按层编号是指：将一棵二叉树中的所有n个结点按从第一层到最大层，每层从左到右的顺序依次标记为1，2，…，n。则对任一编号为i（1≤i≤n）的结点A有：  
　　（1）若i=1，则结点A是根；若i>1，则A的双亲Parent（A）的编号为 ；  
　　（2）若2*i>n，则结点A既无左孩子，也无右孩子；否则A的左孩子Lchild（X）的编号为2*i；  
　　（3）若2*i＋1>n，则结点A无右孩子；否则，A的右孩子Rchild（A）的编号为2*i＋1。

### 二叉树的存储结构

### 二叉树的顺序存储结构

二叉树的顺序存储结构可以用一维数组来实现，二叉树上的结点按某种次序分别存入该数组的各个单元中。

### 二叉树的链式存储结构

二叉树有不同的链式存储结构，其中最常用的是二叉链表与三叉链表。

## 二叉树的遍历

#### 二叉树遍历的递归实现

二叉树的遍历是指按某种次序访问二叉树上的所有结点，使每个结点被访问一次且仅被访问一次。

1.先序遍历  
若被遍历的二叉树为空，执行空操作；否则，依次执行下列操作：  
（1）访问根结点；  
（2）先序遍历左子树；  
（3）先序遍历右子树。

2.中序遍历.  
若被遍历的二叉树为空，执行空操作；否则，依次执行下列操作：  
（1）中序遍历左子树；  
（2）访问根结点；  
（3）中序遍历右子树。

3.后序遍历  
若被遍历的二叉树为空，执行空操作；否则，依次执行下列操作：  
（1）后序遍历左子树；  
（2）后序遍历右子树；  
（3）访问根结点。

#### 二叉树的层次遍历

所谓二叉树的层次遍历，是指从二叉树的根结点的这一层开始，逐层向下遍历，在每一层上按从左到右的顺序对结点逐个访问。

# 树和森林

## 树的存储结构

孩子链表表示法
孩子链表表示法是树的一种链式存储结构。它的主体是一个数组元素个数和树中结点个数相同的一维数组。树上的一个结点X以及该结点的所有孩子结点组成一个带头结点的单链表，单链表的头结点含有两个域：数据域和指针域。其中，数据域用于存储结点X中的数据元素，指针域用于存储指向X第一个孩子结点的指针。

孩子兄弟链表表示法
存储时每个结点除了数据域外，还有指向该结点的第一个孩子和下一个兄弟结点的指针。

双亲表示法
双亲表示法由一个一维数组构成。数组的每个分量包含两个域：数据域和双亲域。数据域用于存储树上一个结点中数据元素，双亲域用于存储本结点的双亲结点在数组中的序号（下标值）。

## 树与森林的遍历

## 树、森林与二叉树的关系

树转换为二叉树
任何一棵树可唯一地与一棵二叉树对应。相应地，一棵二叉树也唯一地对应一棵树，即树与二叉树可以互相转换。

将树转换成二叉树的方法如下：  
1. 将所有兄弟结点连接起来；  
2. 保留第一个兄弟结点与父结点的连接，断开其他兄弟结点与父结点的连接，然后以根结点为轴心按顺时针的方向旋转45°角。


森林F转换成二叉树的方法如下：  
1. 将每棵树转换成相应的二叉树；  
2. 将（1）中得到的各棵二叉树的根结点看作是兄弟连接起来。图4－18为森林转换到二叉树的过程。

将二叉树转换成对应的森林的方法如下：  
1. 在待转换的二叉树中，断开根结点与右孩子的连线，得到两棵二叉树，其中一棵是以二叉树B的根结点为根的二叉树，另一棵是以根结点的右孩子E为根结点的二叉树。图4－19a中，断开A与E的连线后得到两棵如图4－19b所示两棵的二叉树B1和B2。
2. 在二叉树B1中，连接A与C，A与D。然后将B和C的连线断开，C和D的连线断开。  
3. 重复步骤（1）（2）对B2进行转换。

1.树的遍历  
　　与二叉树类似，这里我们定义树的先序遍历、后序遍历和层次遍历。  
　　（1）先序遍历：  
　　①访问根结点；  
　　②依次先序遍历根的各棵子树T1，…，Tm。  
　　对图4－13a所示的树来说，先序遍历得到结点访问序列为H，A，B，E，G，F，D，C；  
　　（2）后序遍历  
　　①依次后序遍历根的各棵子树T1，…，Tm；  
　　②访问根结点。  
　　对图4－13a所示的树来说，后序遍历得到结点访问序列为B，G，F，D，E，A，C，H；  
　　（3）层序遍历  
　　①若树非空，访问根结点；  
　　②若第i（i≥1）层结点已被访问，第i＋1层结点尚未访问，则从左到右依次访问第i＋1层结点。  
　　对图4－13a所示的树来说，层次遍历得到结点访问序列为H，A，C，B，E，G，F，D。

　　2.森林的遍历  
　　森林有两种遍历方法：  
　　（1）先序遍历森林。若森林非空，则  
　　①访问森林中第一棵树的根结点；  
　　②先序遍历森林第一棵树的根结点的子树组成的森林；  
　　③先序遍历除去第一棵树之外其余的树组成的森林。  
　　对图4－18a中的森林进行先序遍历，得到的先序序列为ABCDEFGHJI。  
　　（2）中序遍历森林。若森林非空，则  
　　①中序遍历森林中第一棵树的根结点的子树组成的森林；  
　　②访问第一棵树的根结点；  
　　③中序遍历除去第一棵树之外其余的树组成的森林。

判定树和哈夫曼树
哈夫曼树

通常希望字符在传输过程中总的编码长度越短越好。考虑到一个待传输的文本中不同字符出现的频率是不同的，直观的想法是让出现频率较多的字符采用较短的编码，则传输的字符总编码长度会减少。用哈夫曼树就可以解决这一问题。  
　　将{p1，……，pn}作为一组叶结点的权值，用哈夫曼算法，可以构造出一棵具有最小带权路径长度的二叉树。将该二叉树中每个结点的左分支标志为“0”，每个结点的右分支标志为“1”，这样，从根到每个叶结点形成“0”/“1”序列，将该序列作为叶结点对应字符的编码，由此得到的二进制编码称为哈夫曼编码。
　　
哈夫曼算法